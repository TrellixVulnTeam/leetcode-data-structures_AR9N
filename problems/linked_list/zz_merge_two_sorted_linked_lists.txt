https://leetcode.com/problems/merge-two-sorted-lists/

Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4

Notes:
-----
- This problem wants us to return a sorted merged LinkedList and input will always be two sorted LLs.
- Remember, in solving Linked List,
    - curr is your moving pointer that will be iterated through
    - head is your fixed pointer that will typically remain untouched
- You traverse a Linked List via curr and return the entire List via head!
- We use currX to traverse through Linked List X
- We use currY to traverse through Linked List Y

Solution (Iterative):
--------
Part I : Initialization
- Remember a list can be defined by one ListNode object, Therefore ListNode x and ListNode y will merge into ListNode head.
- We first need to initialize currX = x, currY = y.
- We also initialize curr = new ListNode(0), this makes the solution easier for our base case
- We also need to set the merged Linked List head = curr as reference since we will be traversing via curr

Part II : Base Case
- We need to figure out which list to point to first. X or Y?
- We determine this by checking which ListNode has a lesser ListNode value.

Part III : Main Condition (Loop)


Part IV : Final Case
- If you pay close attention, you'll notice that your loop ends with the following:
    - One LL has 1 node
    - Other LL has all the nodes
- The final next of either x or y depending on which way you went, will end up being null from the final loop!
- Depending on which one is null, you'll have to point curr.next to the opposite list.


Iterating through the solution:

124     134     BASE CASE (in this case; x<=y -> x)
x       y
z               Set z pointer to x
 x              Traverse x

124     134     LOOP1 (in this case; x>y -> y)
24      1134    Set z.next pointer to y
x       zy
         zy     Traverse y and z
24      1134    LOOP2 (in this case; x<=y -> x)
1124      34    Set z.next pointer to x
 zx       y
  zx            Traverse x and z

1124      34    LOOP3 (in this case; x>y -> y)
4       11234   Set z.next pointer to y
x         zy
           zy   Traverse y and z

4       11234   LOOP4 (in this case; x<=y -> x)
11234       4   Set z.next pointer to x
   zx       y
    z           Traverse x and z [Notice that x = null]

                Within loop, add another case (if x = null, z.next = y; and vise versa)

112344

11,34
11,24